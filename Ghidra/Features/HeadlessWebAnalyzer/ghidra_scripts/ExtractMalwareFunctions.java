/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//Extract malware-relevant function calls and API usage patterns
//@category MalwareAnalysis
//@keybinding
//@menupath Analysis.Malware.Extract Functions
//@toolbar

import java.util.*;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.address.*;

public class ExtractMalwareFunctions extends GhidraScript {

    // Suspicious API categories
    private static final Map<String, Set<String>> SUSPICIOUS_APIs = new HashMap<>();
    
    static {
        // File Operations
        Set<String> fileOps = new HashSet<>(Arrays.asList(
            "CreateFileA", "CreateFileW", "WriteFile", "ReadFile", "DeleteFileA", "DeleteFileW",
            "MoveFileA", "MoveFileW", "CopyFileA", "CopyFileW", "FindFirstFileA", "FindFirstFileW"
        ));
        SUSPICIOUS_APIs.put("File Operations", fileOps);
        
        // Registry Operations
        Set<String> regOps = new HashSet<>(Arrays.asList(
            "RegOpenKeyA", "RegOpenKeyW", "RegCreateKeyA", "RegCreateKeyW", 
            "RegSetValueExA", "RegSetValueExW", "RegQueryValueExA", "RegQueryValueExW",
            "RegDeleteKeyA", "RegDeleteKeyW", "RegDeleteValueA", "RegDeleteValueW"
        ));
        SUSPICIOUS_APIs.put("Registry Operations", regOps);
        
        // Network Operations
        Set<String> netOps = new HashSet<>(Arrays.asList(
            "InternetOpenA", "InternetOpenW", "InternetConnectA", "InternetConnectW",
            "HttpOpenRequestA", "HttpOpenRequestW", "HttpSendRequestA", "HttpSendRequestW",
            "WSAStartup", "socket", "connect", "send", "recv", "bind", "listen"
        ));
        SUSPICIOUS_APIs.put("Network Operations", netOps);
        
        // Process/Thread Operations
        Set<String> procOps = new HashSet<>(Arrays.asList(
            "CreateProcessA", "CreateProcessW", "OpenProcess", "TerminateProcess",
            "CreateThread", "CreateRemoteThread", "SuspendThread", "ResumeThread",
            "WriteProcessMemory", "ReadProcessMemory", "VirtualAllocEx"
        ));
        SUSPICIOUS_APIs.put("Process/Thread Operations", procOps);
        
        // Crypto Operations
        Set<String> cryptoOps = new HashSet<>(Arrays.asList(
            "CryptAcquireContextA", "CryptAcquireContextW", "CryptCreateHash",
            "CryptHashData", "CryptDeriveKey", "CryptEncrypt", "CryptDecrypt",
            "CryptGenKey", "CryptExportKey", "CryptImportKey"
        ));
        SUSPICIOUS_APIs.put("Crypto Operations", cryptoOps);
        
        // System Information
        Set<String> sysInfo = new HashSet<>(Arrays.asList(
            "GetSystemDirectoryA", "GetSystemDirectoryW", "GetWindowsDirectoryA", "GetWindowsDirectoryW",
            "GetComputerNameA", "GetComputerNameW", "GetUserNameA", "GetUserNameW",
            "GetVersionExA", "GetVersionExW", "IsDebuggerPresent", "CheckRemoteDebuggerPresent"
        ));
        SUSPICIOUS_APIs.put("System Information", sysInfo);
    }

    @Override
    public void run() throws Exception {
        if (currentProgram == null) {
            println("No program loaded");
            return;
        }

        println("=== Malware Function Analysis ===");
        println("Program: " + currentProgram.getName());
        println();

        Map<String, List<FunctionCall>> categorizedCalls = new HashMap<>();
        for (String category : SUSPICIOUS_APIs.keySet()) {
            categorizedCalls.put(category, new ArrayList<>());
        }

        // Analyze function calls
        analyzeFunctionCalls(categorizedCalls);

        // Analyze imported functions
        analyzeImportedFunctions(categorizedCalls);

        // Print results
        printResults(categorizedCalls);

        // Additional analysis
        analyzeCallPatterns();

        println("\n=== Function Analysis Complete ===");
    }

    private void analyzeFunctionCalls(Map<String, List<FunctionCall>> categorizedCalls) {
        println("Analyzing function calls...");
        
        FunctionIterator functionIterator = currentProgram.getFunctionManager().getFunctions(true);
        
        while (functionIterator.hasNext() && !monitor.isCancelled()) {
            Function function = functionIterator.next();
            
            InstructionIterator instructions = currentProgram.getListing().getInstructions(function.getBody(), true);
            
            while (instructions.hasNext() && !monitor.isCancelled()) {
                Instruction instruction = instructions.next();
                
                if (instruction.getFlowType().isCall()) {
                    analyzeCallInstruction(instruction, categorizedCalls);
                }
            }
        }
    }

    private void analyzeCallInstruction(Instruction callInstruction, Map<String, List<FunctionCall>> categorizedCalls) {
        Reference[] references = callInstruction.getReferencesFrom();
        
        for (Reference ref : references) {
            if (ref.getReferenceType().isCall()) {
                Address toAddress = ref.getToAddress();
                Function calledFunction = currentProgram.getFunctionManager().getFunctionAt(toAddress);
                
                if (calledFunction != null) {
                    String functionName = calledFunction.getName();
                    
                    // Check if this is a suspicious API call
                    for (Map.Entry<String, Set<String>> entry : SUSPICIOUS_APIs.entrySet()) {
                        String category = entry.getKey();
                        Set<String> apis = entry.getValue();
                        
                        if (apis.contains(functionName)) {
                            FunctionCall call = new FunctionCall(
                                functionName,
                                callInstruction.getAddress().toString(),
                                category,
                                calledFunction.getSignature(true).toString()
                            );
                            
                            categorizedCalls.get(category).add(call);
                            break;
                        }
                    }
                }
            }
        }
    }

    private void analyzeImportedFunctions(Map<String, List<FunctionCall>> categorizedCalls) {
        println("Analyzing imported functions...");
        
        SymbolTable symbolTable = currentProgram.getSymbolTable();
        SymbolIterator symbols = symbolTable.getExternalSymbols();
        
        while (symbols.hasNext() && !monitor.isCancelled()) {
            Symbol symbol = symbols.next();
            String symbolName = symbol.getName();
            
            // Check if this is a suspicious imported API
            for (Map.Entry<String, Set<String>> entry : SUSPICIOUS_APIs.entrySet()) {
                String category = entry.getKey();
                Set<String> apis = entry.getValue();
                
                if (apis.contains(symbolName)) {
                    // Find references to this imported function
                    Reference[] references = symbol.getReferences();
                    
                    for (Reference ref : references) {
                        if (ref.getReferenceType().isData() || ref.getReferenceType().isCall()) {
                            FunctionCall call = new FunctionCall(
                                symbolName,
                                ref.getFromAddress().toString(),
                                category + " (Imported)",
                                "External function"
                            );
                            
                            categorizedCalls.get(category).add(call);
                        }
                    }
                    break;
                }
            }
        }
    }

    private void printResults(Map<String, List<FunctionCall>> categorizedCalls) {
        int totalCalls = 0;
        
        for (Map.Entry<String, List<FunctionCall>> entry : categorizedCalls.entrySet()) {
            String category = entry.getKey();
            List<FunctionCall> calls = entry.getValue();
            
            if (!calls.isEmpty()) {
                totalCalls += calls.size();
                println("\n" + category + " (" + calls.size() + " calls):");
                println("=" + "=".repeat(category.length() + 15));
                
                // Group by function name for cleaner output
                Map<String, List<FunctionCall>> groupedCalls = new HashMap<>();
                for (FunctionCall call : calls) {
                    groupedCalls.computeIfAbsent(call.functionName, k -> new ArrayList<>()).add(call);
                }
                
                for (Map.Entry<String, List<FunctionCall>> funcEntry : groupedCalls.entrySet()) {
                    String funcName = funcEntry.getKey();
                    List<FunctionCall> funcCalls = funcEntry.getValue();
                    
                    println("  " + funcName + " (" + funcCalls.size() + " references):");
                    for (FunctionCall call : funcCalls) {
                        println("    @ " + call.address);
                    }
                }
            }
        }
        
        println("\nTotal suspicious API calls found: " + totalCalls);
    }

    private void analyzeCallPatterns() {
        println("\n=== Call Pattern Analysis ===");
        
        // Look for specific malware patterns
        analyzeAntiDebugPatterns();
        analyzePersistencePatterns();
        analyzeEvasionPatterns();
    }

    private void analyzeAntiDebugPatterns() {
        Set<String> antiDebugAPIs = new HashSet<>(Arrays.asList(
            "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugStringA",
            "GetTickCount", "QueryPerformanceCounter"
        ));
        
        int antiDebugCount = countAPIUsage(antiDebugAPIs);
        if (antiDebugCount > 0) {
            println("⚠️  Anti-debugging techniques detected (" + antiDebugCount + " calls)");
        }
    }

    private void analyzePersistencePatterns() {
        Set<String> persistenceAPIs = new HashSet<>(Arrays.asList(
            "RegSetValueExA", "RegSetValueExW", "CreateServiceA", "CreateServiceW",
            "SetWindowsHookExA", "SetWindowsHookExW"
        ));
        
        int persistenceCount = countAPIUsage(persistenceAPIs);
        if (persistenceCount > 0) {
            println("⚠️  Persistence mechanisms detected (" + persistenceCount + " calls)");
        }
    }

    private void analyzeEvasionPatterns() {
        Set<String> evasionAPIs = new HashSet<>(Arrays.asList(
            "VirtualProtect", "VirtualAlloc", "WriteProcessMemory", 
            "CreateRemoteThread", "SetThreadContext"
        ));
        
        int evasionCount = countAPIUsage(evasionAPIs);
        if (evasionCount > 0) {
            println("⚠️  Code injection/evasion techniques detected (" + evasionCount + " calls)");
        }
    }

    private int countAPIUsage(Set<String> apis) {
        int count = 0;
        SymbolTable symbolTable = currentProgram.getSymbolTable();
        
        for (String api : apis) {
            List<Symbol> symbols = symbolTable.getSymbols(api);
            for (Symbol symbol : symbols) {
                count += symbol.getReferences().length;
            }
        }
        
        return count;
    }

    // Helper class to store function call information
    private static class FunctionCall {
        String functionName;
        String address;
        String category;
        String signature;
        
        FunctionCall(String functionName, String address, String category, String signature) {
            this.functionName = functionName;
            this.address = address;
            this.category = category;
            this.signature = signature;
        }
    }
}