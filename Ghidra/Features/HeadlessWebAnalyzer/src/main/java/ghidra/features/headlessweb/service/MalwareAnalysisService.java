/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidra.features.headlessweb.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import ghidra.app.util.headless.HeadlessAnalyzer;
import ghidra.app.util.headless.HeadlessOptions;
import ghidra.features.headlessweb.model.*;
import ghidra.framework.Application;
import ghidra.framework.ApplicationConfiguration;
import ghidra.framework.HeadlessGhidraApplicationConfiguration;

/**
 * Core service for malware analysis operations using Ghidra headless analyzer
 */
public class MalwareAnalysisService {
    
    private final Map<String, AnalysisResult> analysisResults = new ConcurrentHashMap<>();
    private final Map<String, AnalysisStatus> analysisStatusMap = new ConcurrentHashMap<>();
    private final Path tempDir;
    private final Path projectDir;
    
    public MalwareAnalysisService() {
        try {
            this.tempDir = Files.createTempDirectory("ghidra-web-analysis");
            this.projectDir = Files.createTempDirectory("ghidra-web-projects");
            initializeGhidra();
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize analysis service", e);
        }
    }
    
    private void initializeGhidra() {
        // Initialize Ghidra application in headless mode
        ApplicationConfiguration config = new HeadlessGhidraApplicationConfiguration();
        try {
            Application.initializeApplication(config);
        } catch (Exception e) {
            System.err.println("Warning: Ghidra application may already be initialized: " + e.getMessage());
        }
    }
    
    /**
     * Analyze a file using default analysis workflow
     */
    public CompletableFuture<AnalysisResult> analyzeFile(File file, AnalysisOptions options) {
        String analysisId = UUID.randomUUID().toString();
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                updateStatus(analysisId, AnalysisStatus.Status.RUNNING, "Starting analysis...");
                
                // Create unique project for this analysis
                String projectName = "Analysis_" + analysisId;
                File projectLocation = new File(projectDir.toFile(), projectName);
                
                updateStatus(analysisId, AnalysisStatus.Status.RUNNING, "Importing file...");
                
                // Prepare headless analyzer
                HeadlessAnalyzer analyzer = new HeadlessAnalyzer();
                HeadlessOptions headlessOptions = new HeadlessOptions();
                headlessOptions.enableAnalysis(options.isAnalysisEnabled());
                
                // Execute analysis
                updateStatus(analysisId, AnalysisStatus.Status.RUNNING, "Performing analysis...");
                
                // For now, create a mock result - in real implementation, this would use the actual analyzer
                AnalysisResult result = performActualAnalysis(file, projectLocation, options);
                result.setAnalysisId(analysisId);
                
                analysisResults.put(analysisId, result);
                updateStatus(analysisId, AnalysisStatus.Status.COMPLETED, "Analysis completed successfully");
                
                return result;
                
            } catch (Exception e) {
                updateStatus(analysisId, AnalysisStatus.Status.FAILED, "Analysis failed: " + e.getMessage());
                throw new RuntimeException("Analysis failed", e);
            }
        });
    }
    
    /**
     * Execute custom headless command
     */
    public CompletableFuture<AnalysisResult> executeCustomCommand(String command, AnalysisOptions options) {
        String analysisId = UUID.randomUUID().toString();
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                updateStatus(analysisId, AnalysisStatus.Status.RUNNING, "Executing custom command...");
                
                // Parse and execute the custom headless command
                AnalysisResult result = executeHeadlessCommand(command, analysisId);
                result.setAnalysisId(analysisId);
                
                analysisResults.put(analysisId, result);
                updateStatus(analysisId, AnalysisStatus.Status.COMPLETED, "Custom command executed successfully");
                
                return result;
                
            } catch (Exception e) {
                updateStatus(analysisId, AnalysisStatus.Status.FAILED, "Command execution failed: " + e.getMessage());
                throw new RuntimeException("Command execution failed", e);
            }
        });
    }
    
    private AnalysisResult performActualAnalysis(File file, File projectLocation, AnalysisOptions options) {
        AnalysisResult result = new AnalysisResult();
        result.setFileName(file.getName());
        result.setFileSize(file.length());
        result.setTimestamp(new Date());
        
        // Extract basic file information
        result.setFileHash(calculateFileHash(file));
        result.setFileType(detectFileType(file));
        
        // Mock analysis results - in real implementation, this would extract from actual Ghidra analysis
        result.setFunctionCalls(extractMockFunctionCalls());
        result.setIocs(extractMockIOCs());
        result.setInterestingStrings(extractMockStrings());
        result.setMalwareCategory(categorizeMalware(file, result));
        
        return result;
    }
    
    private AnalysisResult executeHeadlessCommand(String command, String analysisId) {
        // Parse and execute headless command
        // For now, return mock result
        AnalysisResult result = new AnalysisResult();
        result.setAnalysisId(analysisId);
        result.setCustomCommand(command);
        result.setTimestamp(new Date());
        
        // Extract relevant information from command execution
        result.setFunctionCalls(extractMockFunctionCalls());
        result.setIocs(extractMockIOCs());
        result.setInterestingStrings(extractMockStrings());
        
        return result;
    }
    
    /**
     * Extract IOCs from analysis result
     */
    public IOCResult extractIOCs(String analysisId) {
        AnalysisResult result = analysisResults.get(analysisId);
        if (result == null) {
            throw new IllegalArgumentException("Analysis not found: " + analysisId);
        }
        
        return result.getIocs();
    }
    
    /**
     * Extract function calls from analysis result
     */
    public List<FunctionCall> extractFunctions(String analysisId) {
        AnalysisResult result = analysisResults.get(analysisId);
        if (result == null) {
            throw new IllegalArgumentException("Analysis not found: " + analysisId);
        }
        
        return result.getFunctionCalls();
    }
    
    /**
     * Extract interesting strings from analysis result
     */
    public List<String> extractStrings(String analysisId) {
        AnalysisResult result = analysisResults.get(analysisId);
        if (result == null) {
            throw new IllegalArgumentException("Analysis not found: " + analysisId);
        }
        
        return result.getInterestingStrings();
    }
    
    /**
     * Get all available malware categories
     */
    public List<String> getMalwareCategories() {
        return Arrays.asList(
            "Trojan", "Ransomware", "Spyware", "Adware", "Worm", 
            "Rootkit", "Backdoor", "Bot", "Keylogger", "Unknown"
        );
    }
    
    /**
     * Categorize malware based on analysis results
     */
    public String categorizeMalware(String analysisId) {
        AnalysisResult result = analysisResults.get(analysisId);
        if (result == null) {
            throw new IllegalArgumentException("Analysis not found: " + analysisId);
        }
        
        return result.getMalwareCategory();
    }
    
    /**
     * Get malware samples by category
     */
    public List<AnalysisResult> getMalwareByCategory(String category) {
        return analysisResults.values().stream()
            .filter(result -> category.equals(result.getMalwareCategory()))
            .toList();
    }
    
    public AnalysisResult getAnalysisResult(String analysisId) {
        return analysisResults.get(analysisId);
    }
    
    public AnalysisStatus getAnalysisStatus(String analysisId) {
        return analysisStatusMap.get(analysisId);
    }
    
    public List<AnalysisResult> getAllResults() {
        return new ArrayList<>(analysisResults.values());
    }
    
    private void updateStatus(String analysisId, AnalysisStatus.Status status, String message) {
        AnalysisStatus analysisStatus = analysisStatusMap.computeIfAbsent(analysisId, 
            k -> new AnalysisStatus(analysisId));
        analysisStatus.setStatus(status);
        analysisStatus.setMessage(message);
        analysisStatus.setLastUpdated(new Date());
    }
    
    // Mock implementations - replace with actual Ghidra analysis
    private String calculateFileHash(File file) {
        return "sha256:" + Integer.toHexString(file.getAbsolutePath().hashCode());
    }
    
    private String detectFileType(File file) {
        String name = file.getName().toLowerCase();
        if (name.endsWith(".exe") || name.endsWith(".dll")) return "PE";
        if (name.endsWith(".so")) return "ELF";
        if (name.endsWith(".dylib")) return "Mach-O";
        return "Unknown";
    }
    
    private List<FunctionCall> extractMockFunctionCalls() {
        return Arrays.asList(
            new FunctionCall("CreateFileA", "0x401000", Arrays.asList("\"malicious.txt\"", "GENERIC_WRITE")),
            new FunctionCall("RegSetValueExA", "0x401050", Arrays.asList("HKEY_CURRENT_USER", "\"Software\\\\Test\"")),
            new FunctionCall("InternetOpenA", "0x401080", Arrays.asList("\"Mozilla/5.0\""))
        );
    }
    
    private IOCResult extractMockIOCs() {
        IOCResult iocs = new IOCResult();
        iocs.setIpAddresses(Arrays.asList("192.168.1.100", "10.0.0.1"));
        iocs.setDomains(Arrays.asList("malicious-domain.com", "c2-server.net"));
        iocs.setUrls(Arrays.asList("http://malicious-domain.com/payload.exe"));
        iocs.setFileHashes(Arrays.asList("d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4"));
        iocs.setRegistryKeys(Arrays.asList("HKEY_CURRENT_USER\\Software\\Test"));
        iocs.setMutexes(Arrays.asList("Global\\MalwareMutex"));
        return iocs;
    }
    
    private List<String> extractMockStrings() {
        return Arrays.asList(
            "malicious.txt",
            "http://malicious-domain.com",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            "Global\\MalwareMutex"
        );
    }
    
    private String categorizeMalware(File file, AnalysisResult result) {
        // Simple heuristic-based categorization - in real implementation would use ML
        List<String> strings = result.getInterestingStrings();
        List<FunctionCall> functions = result.getFunctionCalls();
        
        if (strings.stream().anyMatch(s -> s.toLowerCase().contains("ransom"))) {
            return "Ransomware";
        }
        if (functions.stream().anyMatch(f -> f.getFunctionName().contains("Reg"))) {
            return "Trojan";
        }
        if (strings.stream().anyMatch(s -> s.toLowerCase().contains("keylog"))) {
            return "Keylogger";
        }
        
        return "Unknown";
    }
}